/*
 * Marlowe Runtime REST API
 *
 * REST API for Marlowe Runtime
 *
 * The version of the OpenAPI document: 0.0.5.1
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest::header::HeaderMap;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`apply_inputs_to_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApplyInputsToContractError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateContractError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_contract_sources`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateContractSourcesError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contract_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractByIdError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contract_source_adjacency`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractSourceAdjacencyError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contract_source_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractSourceByIdError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contract_source_closure`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractSourceClosureError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contract_transaction_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractTransactionByIdError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_contracts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContractsError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_next_steps_for_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNextStepsForContractError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_payout_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPayoutByIdError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_payouts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPayoutsError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transactions_for_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionsForContractError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_withdrawal_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWithdrawalByIdError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_withdrawals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWithdrawalsError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`healthcheck`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HealthcheckError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_contract`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitContractError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_contract_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitContractTransactionError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_withdrawal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitWithdrawalError {
    Status400(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`withdraw_payouts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WithdrawPayoutsError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
pub async fn apply_inputs_to_contract(
    configuration: &configuration::Configuration,
    contract_id: &str,
    x_change_address: &str,
    x_address: Option<&str>,
    x_collateral_utx_o: Option<&str>,
    post_transactions_request: Option<crate::models::PostTransactionsRequest>,
) -> Result<(crate::models::ApplyInputsResponse, HeaderMap), Error<ApplyInputsToContractError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/{contractId}/transactions",
        local_var_configuration.base_path,
        contractId = crate::apis::urlencode(contract_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder =
        local_var_req_builder.header("X-Change-Address", x_change_address.to_string());
    if let Some(local_var_param_value) = x_address {
        local_var_req_builder =
            local_var_req_builder.header("X-Address", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_collateral_utx_o {
        local_var_req_builder =
            local_var_req_builder.header("X-Collateral-UTxO", local_var_param_value.to_string());
    }

    local_var_req_builder = local_var_req_builder.header(
        "Accept",
        "application/vendor.iog.marlowe-runtime.apply-inputs-tx-json".to_string(),
    );

    local_var_req_builder = local_var_req_builder.json(&post_transactions_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<ApplyInputsToContractError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
pub async fn create_contract(
    configuration: &configuration::Configuration,
    x_change_address: &str,
    x_stake_address: Option<&str>,
    x_address: Option<&str>,
    x_collateral_utx_o: Option<&str>,
    post_contracts_request: Option<crate::models::PostContractsRequest>,
) -> Result<(crate::models::CreateContractResponse, HeaderMap), Error<CreateContractError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contracts", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = x_stake_address {
        local_var_req_builder =
            local_var_req_builder.header("X-Stake-Address", local_var_param_value.to_string());
    }
    local_var_req_builder =
        local_var_req_builder.header("X-Change-Address", x_change_address.to_string());
    if let Some(local_var_param_value) = x_address {
        local_var_req_builder =
            local_var_req_builder.header("X-Address", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_collateral_utx_o {
        local_var_req_builder =
            local_var_req_builder.header("X-Collateral-UTxO", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header(
        "Accept",
        "application/vendor.iog.marlowe-runtime.contract-tx-json".to_string(),
    );
    local_var_req_builder = local_var_req_builder.json(&post_contracts_request);
    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().to_owned();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<CreateContractError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
pub async fn create_contract_sources(
    configuration: &configuration::Configuration,
    main: &str,
    labelled_object: Option<Vec<crate::models::LabelledObject>>,
) -> Result<(crate::models::PostContractSourceResponse, HeaderMap), Error<CreateContractSourcesError>>
{
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contracts/sources", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("main", &main.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&labelled_object);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<CreateContractSourcesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_contract_by_id(
    configuration: &configuration::Configuration,
    contract_id: &str,
) -> Result<(crate::models::GetContractResponse, HeaderMap), Error<GetContractByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/{contractId}",
        local_var_configuration.base_path,
        contractId = crate::apis::urlencode(contract_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetContractByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
pub async fn get_contract_source_adjacency(
    configuration: &configuration::Configuration,
    contract_source_id: &str,
) -> Result<(crate::models::ContractSourceIds, HeaderMap), Error<GetContractSourceAdjacencyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/sources/{contractSourceId}/adjacency",
        local_var_configuration.base_path,
        contractSourceId = crate::apis::urlencode(contract_source_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetContractSourceAdjacencyError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_contract_source_by_id(
    configuration: &configuration::Configuration,
    contract_source_id: &str,
    expand: Option<bool>,
) -> Result<(crate::models::Contract, HeaderMap), Error<GetContractSourceByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/sources/{contractSourceId}",
        local_var_configuration.base_path,
        contractSourceId = crate::apis::urlencode(contract_source_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = expand {
        local_var_req_builder =
            local_var_req_builder.query(&[("expand", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetContractSourceByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
pub async fn get_contract_source_closure(
    configuration: &configuration::Configuration,
    contract_source_id: &str,
) -> Result<(crate::models::ContractSourceIds, HeaderMap), Error<GetContractSourceClosureError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/sources/{contractSourceId}/closure",
        local_var_configuration.base_path,
        contractSourceId = crate::apis::urlencode(contract_source_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetContractSourceClosureError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_contract_transaction_by_id(
    configuration: &configuration::Configuration,
    contract_id: &str,
    transaction_id: &str,
) -> Result<
    (crate::models::GetTransactionResponse, HeaderMap),
    Error<GetContractTransactionByIdError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/{contractId}/transactions/{transactionId}",
        local_var_configuration.base_path,
        contractId = crate::apis::urlencode(contract_id),
        transactionId = crate::apis::urlencode(transaction_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetContractTransactionByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
pub async fn get_contracts(
    configuration: &configuration::Configuration,
    role_currency: Option<Vec<String>>,
    tag: Option<Vec<String>>,
    party_address: Option<Vec<String>>,
    party_role: Option<Vec<String>>,
    range: Option<&str>,
) -> Result<(crate::models::GetContractsResponse, HeaderMap), Error<GetContractsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/contracts", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = role_currency {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("roleCurrency".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "roleCurrency",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = tag {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("tag".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "tag",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = party_address {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("partyAddress".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "partyAddress",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = party_role {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("partyRole".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "partyRole",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = range {
        local_var_req_builder =
            local_var_req_builder.header("Range", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().to_owned();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetContractsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get inputs which could be performed on a contract withing a time range by the requested parties.
pub async fn get_next_steps_for_contract(
    configuration: &configuration::Configuration,
    contract_id: &str,
    validity_start: &str,
    validity_end: &str,
    party: Option<Vec<String>>,
) -> Result<(crate::models::Next, HeaderMap), Error<GetNextStepsForContractError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/{contractId}/next",
        local_var_configuration.base_path,
        contractId = crate::apis::urlencode(contract_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder =
        local_var_req_builder.query(&[("validityStart", &validity_start.to_string())]);
    local_var_req_builder =
        local_var_req_builder.query(&[("validityEnd", &validity_end.to_string())]);
    if let Some(ref local_var_str) = party {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("party".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "party",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetNextStepsForContractError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_payout_by_id(
    configuration: &configuration::Configuration,
    payout_id: &str,
) -> Result<(crate::models::GetPayoutResponse, HeaderMap), Error<GetPayoutByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/payouts/{payoutId}",
        local_var_configuration.base_path,
        payoutId = crate::apis::urlencode(payout_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetPayoutByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
pub async fn get_payouts(
    configuration: &configuration::Configuration,
    contract_id: Option<Vec<String>>,
    role_token: Option<Vec<String>>,
    status: Option<&str>,
    range: Option<&str>,
) -> Result<(crate::models::GetPayoutsResponse, HeaderMap), Error<GetPayoutsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/payouts", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = contract_id {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("contractId".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "contractId",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = role_token {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("roleToken".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "roleToken",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = range {
        local_var_req_builder =
            local_var_req_builder.header("Range", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetPayoutsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
pub async fn get_transactions_for_contract(
    configuration: &configuration::Configuration,
    contract_id: &str,
    range: Option<&str>,
) -> Result<
    (crate::models::GetTransactionsResponse, HeaderMap),
    Error<GetTransactionsForContractError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/{contractId}/transactions",
        local_var_configuration.base_path,
        contractId = crate::apis::urlencode(contract_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = range {
        local_var_req_builder =
            local_var_req_builder.header("Range", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetTransactionsForContractError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_withdrawal_by_id(
    configuration: &configuration::Configuration,
    withdrawal_id: &str,
) -> Result<(crate::models::Withdrawal, HeaderMap), Error<GetWithdrawalByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/withdrawals/{withdrawalId}",
        local_var_configuration.base_path,
        withdrawalId = crate::apis::urlencode(withdrawal_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetWithdrawalByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
pub async fn get_withdrawals(
    configuration: &configuration::Configuration,
    role_currency: Option<Vec<String>>,
    range: Option<&str>,
) -> Result<(crate::models::GetWithdrawalsResponse, HeaderMap), Error<GetWithdrawalsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/withdrawals", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = role_currency {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("roleCurrency".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "roleCurrency",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(local_var_param_value) = range {
        local_var_req_builder =
            local_var_req_builder.header("Range", local_var_param_value.to_string());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<GetWithdrawalsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Check if the server is running and ready to respond to requests.
pub async fn healthcheck(
    configuration: &configuration::Configuration,
) -> Result<HeaderMap, Error<HealthcheckError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/healthcheck", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(headers)
    } else {
        let local_var_entity: Option<HealthcheckError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
pub async fn submit_contract(
    configuration: &configuration::Configuration,
    contract_id: &str,
    text_envelope: Option<crate::models::TextEnvelope>,
) -> Result<HeaderMap, Error<SubmitContractError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/{contractId}",
        local_var_configuration.base_path,
        contractId = crate::apis::urlencode(contract_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&text_envelope);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(headers)
    } else {
        let local_var_entity: Option<SubmitContractError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
pub async fn submit_contract_transaction(
    configuration: &configuration::Configuration,
    contract_id: &str,
    transaction_id: &str,
    text_envelope: Option<crate::models::TextEnvelope>,
) -> Result<HeaderMap, Error<SubmitContractTransactionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/contracts/{contractId}/transactions/{transactionId}",
        local_var_configuration.base_path,
        contractId = crate::apis::urlencode(contract_id),
        transactionId = crate::apis::urlencode(transaction_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&text_envelope);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(headers)
    } else {
        let local_var_entity: Option<SubmitContractTransactionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
pub async fn submit_withdrawal(
    configuration: &configuration::Configuration,
    withdrawal_id: &str,
    text_envelope: Option<crate::models::TextEnvelope>,
) -> Result<HeaderMap, Error<SubmitWithdrawalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/withdrawals/{withdrawalId}",
        local_var_configuration.base_path,
        withdrawalId = crate::apis::urlencode(withdrawal_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&text_envelope);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(headers)
    } else {
        let local_var_entity: Option<SubmitWithdrawalError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
pub async fn withdraw_payouts(
    configuration: &configuration::Configuration,
    x_change_address: &str,
    x_address: Option<&str>,
    x_collateral_utx_o: Option<&str>,
    post_withdrawals_request: Option<crate::models::PostWithdrawalsRequest>,
) -> Result<(crate::models::WithdrawPayoutsResponse, HeaderMap), Error<WithdrawPayoutsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/withdrawals", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder =
        local_var_req_builder.header("X-Change-Address", x_change_address.to_string());
    if let Some(local_var_param_value) = x_address {
        local_var_req_builder =
            local_var_req_builder.header("X-Address", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = x_collateral_utx_o {
        local_var_req_builder =
            local_var_req_builder.header("X-Collateral-UTxO", local_var_param_value.to_string());
    }
    local_var_req_builder = local_var_req_builder.header(
        "Accept",
        "application/vendor.iog.marlowe-runtime.withdraw-tx-json".to_string(),
    );

    local_var_req_builder = local_var_req_builder.json(&post_withdrawals_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let headers = local_var_resp.headers().clone();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok((
            serde_json::from_str(&local_var_content).map_err(Error::from)?,
            headers,
        ))
    } else {
        let local_var_entity: Option<WithdrawPayoutsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
